<!-- Thay thế phần script type="module" hiện tại (chỉ paste phần module) -->
<script type="module">
  import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js';
  import {
    getFirestore,
    collection,
    query,
    orderBy,
    // thay đổi: dùng onSnapshot để realtime
    onSnapshot,
    doc,
    updateDoc,
    deleteDoc,
    writeBatch
  } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore.js';

  const firebaseConfig = {
    apiKey: "AIzaSyAXtnsgM2cu7IdOOq5ZMPuNHpcUtTc_93g",
    authDomain: "it2025-c6ed8.firebaseapp.com",
    projectId: "it2025-c6ed8",
    storageBucket: "it2025-c6ed8.firebasestorage.app",
    messagingSenderId: "784468579580",
    appId: "1:784468579580:web:1b981ba6370aa7cf1b7379",
    measurementId: "G-ERVN4JE01P"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  const attendeesCol = collection(db, 'attendees');

  // ... giữ nguyên config, DOM refs, helper funcs (escapeHtml, roleOf, teamLabelOf, countInTeamId, renderTeams, renderTable, v.v.) ...

  // === Realtime listener thay cho getDocs() một lần ===
  // Ghi chú: dùng orderBy('createdAt','asc') giống trước để giữ thứ tự
  const attendeesQuery = query(attendeesCol, orderBy('createdAt', 'asc'));

  // Đồng bộ localStorage dựa vào participants để các trang trên cùng 1 máy có thể tham khảo
  function syncLocalStorageFromParticipants() {
    try {
      const KEY = 'participants_v1';
      // Lưu chỉ các trường cần thiết để giảm dung lượng
      const dump = participants.map(p => ({
        id: p.id,
        name: p.name || '',
        number: p.number || null,
        role: p.role || '',
        team: p.team || null,
        teamLabel: p.teamLabel || '',
        slogan: p.slogan || '',
        createdAt: p.createdAt ? (p.createdAt.toDate ? p.createdAt.toDate().toISOString() : new Date(p.createdAt).toISOString()) : null
      }));
      localStorage.setItem(KEY, JSON.stringify(dump));
      localStorage.setItem('lastEntryIndex', String(Math.max(0, dump.length - 1)));
    } catch (e) {
      console.warn('Không thể sync localStorage:', e);
    }
  }

  // Listener realtime
  const unsubscribe = onSnapshot(attendeesQuery, (snap) => {
    // Cập nhật toàn bộ participants từ snapshot — cách đơn giản, chính xác
    participants = snap.docs.map(d => ({ id: d.id, ...d.data() }));
    // Cập nhật UI
    renderTeams();
    renderTable();
    // Đồng bộ localStorage TRÊN MÁY NÀY (không tác động tới máy khác)
    syncLocalStorageFromParticipants();
  }, (err) => {
    console.error('Lỗi realtime Firestore:', err);
    alert('Không thể kết nối realtime tới Firestore. Kiểm tra rules & kết nối mạng.');
  });

  // Nếu trước đó bạn có các hàm dùng getDocs() — bỏ/hủy chúng. 
  // Các phần khác (edit, delete, export, reset, sort) giữ nguyên nhưng
  // chỉnh sửa nhỏ: khi xóa/ cập nhật, không cố gắng thao tác trực tiếp trên participants rồi render,
  // vì onSnapshot sẽ tự đẩy cập nhật. Tuy nhiên để UX mượt hơn, ta vẫn cập nhật local state sau update/delete.

  // Ví dụ cập nhật onDeleteClick: (giữ logic xóa Firestore, để onSnapshot cập nhật UI; nhưng vẫn remove localStorage entry tương ứng)
  async function onDeleteClick(e){
    const id = e.currentTarget.dataset.id;
    const rec = participants.find(p => p.id === id);
    if (!rec) return;
    if (!confirm(`Xóa "${rec.name}" khỏi danh sách?`)) return;

    try {
      await deleteDoc(doc(db, 'attendees', id));
      // onSnapshot sẽ cập nhật participants & UI.
      // Đồng thời ta cập nhật localStorage để phản ánh thay đổi trên máy này:
      setTimeout(syncLocalStorageFromParticipants, 300);
      alert(`Đã xóa "${rec.name}" khỏi danh sách.`);
    } catch (err) {
      console.error('Lỗi xóa document:', err);
      alert('Xóa thất bại. Kiểm tra quyền truy cập Firestore.');
    }
  }

  // Reset vẫn dùng batch.commit — onSnapshot sẽ báo về và UI bị làm trống
  resetBtn.addEventListener('click', async ()=>{
    if(!confirm('XÓA TOÀN BỘ dữ liệu trong Firestore và xoá dữ liệu trên máy hiện tại?')) return;
    try {
      const batch = writeBatch(db);
      participants.forEach(p => {
        batch.delete(doc(db, 'attendees', p.id));
      });
      await batch.commit();
      // onSnapshot sẽ cập nhật participants -> []
      // Xoá localStorage cục bộ:
      try { localStorage.removeItem('participants_v1'); localStorage.removeItem('lastEntryIndex'); } catch(e){console.warn(e);}
      alert('Đã reset dữ liệu Firestore và cache trên trình duyệt này. Vui lòng reload các trang check-in.');
    } catch (err) {
      console.error('Lỗi khi reset Firestore:', err);
      alert('Reset thất bại. Kiểm tra quyền & kết nối.');
    }
  });

  // Sort/export/edit logic vẫn hoạt động. Nếu muốn, bạn có thể giữ phần saveEditBtn listener nguyên vẹn
  // nhưng lưu ý: khi updateDoc thành công, onSnapshot sẽ nhận thay đổi và cập nhật UI (tốt).
  // === Init: không cần gọi loadFromFirestore nữa vì onSnapshot đã lắng nghe ngay ===

  // Nếu cần dừng realtime listener khi rời trang: window.addEventListener('beforeunload', ()=> unsubscribe());
</script>


<footer class="site-footer">
  © 2025 Eddy – Web Developer. 47 Slots System.
</footer>
</body>
</html>
